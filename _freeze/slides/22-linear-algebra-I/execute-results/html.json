{
  "hash": "7ca68696a69029f5a8e0ef8001526dc3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Linear algebra I\nsubtitle: Lecture 22\nformat:\n  revealjs: default\neditor_options:\n  chunk_output_type: console\nexecute:\n  warning: false\n  error: false\n---\n\n# Linear algebra\n\n## Linear algebra {.smaller}\n\n> ::: incremental\n> -   Linear algebra is the study of vectors, vector spaces, and linear transformations.\n>\n> -   Fundamental to many fields including data science, machine learning, and statistics.\n> :::\n\n# Vectors\n\n## Vectors {.smaller}\n\n::: fragment\n**Definition:**\n\n::: incremental\n-   Vectors are objects that can be added together and multiplied by scalars to form new vectors. In a data science context, vectors are often used to represent numeric data.\n:::\n:::\n\n::: fragment\n**Examples:**\n\n::: incremental\n-   Three-dimensional vector: \\[height, weight, age\\] = \\[70, 170, 40\\]\n\n-   Four-dimensional vector: \\[exam1, exam2, exam3, exam4\\] = \\[95, 80, 75, 62\\]\n:::\n:::\n\n## Vectors in Python {.smaller}\n\n::: panel-tabset\n## Numpy\n\n::: {#2647047e .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nv = np.array([3, 2])\nprint(v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3 2]\n```\n:::\n:::\n\n\n## Visual\n\n::: {#8af87242 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nv = np.array([3, 2])\norigin = np.array([0, 0])\n\nplt.quiver(*origin, *v, scale=1, scale_units='xy', angles='xy')\nplt.xlim(0, 4)\nplt.ylim(0, 3)\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](22-linear-algebra-I_files/figure-revealjs/cell-3-output-1.png){width=804 height=416}\n:::\n:::\n\n\n:::\n\n## Vector addition {.smaller}\n\n::: panel-tabset\n## Example\n\n::: incremental\n-   Vectors of the same length can be added or subtracted componentwise.\n\n-   Example: $\\mathbf{v} = [3,2]$ and $\\mathbf{w}=[2,-1]$\n\n-   Result: $\\mathbf{v}+\\mathbf{w}=[5,1]$\n:::\n\n## Python\n\n::: {#17576300 .cell execution_count=3}\n``` {.python .cell-code}\nv = np.array([3, 2])\nw = np.array([2, -1])\nv_plus_w = v + w\nprint(v_plus_w) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5 1]\n```\n:::\n:::\n\n\n## Visual\n\n::: {#378bbb73 .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nv = np.array([3, 2])\nw = np.array([2, -1])\nv_plus_w = v + w\n\nplt.quiver(*origin, *v, color='r', scale=1, scale_units='xy', angles='xy')\nplt.quiver(*origin, *w, color='b', scale=1, scale_units='xy', angles='xy')\nplt.quiver(*origin, *v_plus_w, color='g', scale=1, scale_units='xy', angles='xy')\nplt.xlim(0, 6)\nplt.ylim(-2, 3)\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](22-linear-algebra-I_files/figure-revealjs/cell-5-output-1.png){width=796 height=416}\n:::\n:::\n\n\n:::\n\n## Vector subtraction {.smaller}\n\n::: panel-tabset\n## Example\n\n::: incremental\n-   Vectors of the same length can be added or subtracted componentwise.\n\n-   Example: $\\mathbf{v} = [3,2]$ and $\\mathbf{w}=[2,-1]$\n\n-   Result: $\\mathbf{v}-\\mathbf{w}=[1,3]$\n:::\n\n## Python\n\n::: {#ffcdd40e .cell execution_count=5}\n``` {.python .cell-code}\nv = np.array([3, 2])\nw = np.array([2, -1])\nv_plus_w = v - w\nprint(v_plus_w) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 3]\n```\n:::\n:::\n\n\n## Visual\n\n::: {#7687e6fe .cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nv = np.array([3, 2])\nw = np.array([2, -1])\nv_plus_w = v - w\n\nplt.quiver(*origin, *v, color='r', scale=1, scale_units='xy', angles='xy')\nplt.quiver(*origin, *w, color='b', scale=1, scale_units='xy', angles='xy')\nplt.quiver(*origin, *v_plus_w, color='g', scale=1, scale_units='xy', angles='xy')\nplt.xlim(0, 6)\nplt.ylim(-2, 3)\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](22-linear-algebra-I_files/figure-revealjs/cell-7-output-1.png){width=796 height=416}\n:::\n:::\n\n\n:::\n\n## Vector scaling {.smaller}\n\n::: panel-tabset\n## Example\n\n::: incremental\n-   Scaling vector $\\mathbf{v}=[3,2]$ by $2$\n\n-   Result: $[6,4]$\n:::\n\n## Python\n\n::: {#20f6cb94 .cell execution_count=7}\n``` {.python .cell-code}\nv = np.array([3, 2])\nscaled_v = 2.0 * v\nprint(scaled_v)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[6. 4.]\n```\n:::\n:::\n\n\n## Visual\n\n::: {#84b0522a .cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nscaled_v = 2 * v\n\nplt.quiver(*origin, *v, color='r', scale=1, scale_units='xy', angles='xy')\nplt.quiver(*origin, *scaled_v, color='g', scale=1, scale_units='xy', angles='xy', alpha=0.75)\nplt.xlim(0, 7)\nplt.ylim(0, 5)\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](22-linear-algebra-I_files/figure-revealjs/cell-9-output-1.png){width=785 height=416}\n:::\n:::\n\n\n:::\n\n# Linearly independent and span\n\n## Span\n\n> The span of a set of vectors $\\mathbf{v1},\\mathbf{v2},...,\\mathbf{vn}$ is the set of all linear combinations of the vectors.\n>\n> i.e., all the vectors $\\mathbf{b}$ for which the equation $[\\mathbf{v1} \\space \\mathbf{v2} \\space... \\space\\mathbf{vn}]\\mathbf{x=b}$\n\n## Linear independent vs. dependent {.smaller}\n\n> Vectors are **linearly independent** if each vector lies outside the span of the remaining vectors.\n> Otherwise, the vectors are said to be **linearly dependent**[^1].\n\n[^1]: For more information, see this nice [blog on the topic](https://mbernste.github.io/posts/linear_independence/)\n\n![](images/linear_independence.png){fig-align=\"center\" width=\"934\"}\n\n## Linear independent vs. dependent {.smaller}\n\n> The vector on th right can be constructed by any two combination of the other vectors.\n\n![](images/linear_independence_symmetry.png){fig-align=\"center\" width=\"600\"}\n\n# Matrices\n\n## Matrices {.smaller}\n\n::: panel-tabset\n## Definition\n\n-   Matrices are collections of vectors arranged in rows and columns.\n\n-   Represent linear transformations.\n\n-   Example Matrix:\n\n$$\n\\mathbf{A} = \\begin{bmatrix}3 & 0 \\\\0 & 2 \\end{bmatrix}\n$$\n\n## Python\n\n::: {#77eb587d .cell execution_count=9}\n``` {.python .cell-code}\nA = np.array([[3,0],[0,2]])\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[3 0]\n [0 2]]\n```\n:::\n:::\n\n\n:::\n\n## Matrix transposition {.smaller}\n\n-   Matrix transposition involves swapping the rows and columns.\n\n-   Notation: If $\\mathbf{A}$ is a matrix, then its transpose is denoted as $\\mathbf{A}^T$.\n\n-   Given the matrix $\\mathbf{A}$:\n\n$$\n\\mathbf{A}= \\begin{bmatrix}a_{11} & a_{12} & a_{13}\\\\a_{21} & a_{22} & a_{23}\\\\a_{31} & a_{32} & a_{33}\\end{bmatrix}\n$$\n\n-   The matrix $\\mathbf{A}^T$ is:\n\n$$\n\\mathbf{A}^T=\\begin{bmatrix}a_{11} & a_{21} & a_{31}\\\\a_{12} & a_{22} & a_{32}\\\\a_{13} & a_{23} & a_{33}\\end{bmatrix}\n$$\n\n## Matrix transposition: Python\n\n::: {#38a2748e .cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\n\n# Original matrix\nA = np.array([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n])\n\n# Transpose of the matrix\nA_T = A.T\n\nprint(\"Original Matrix:\")\nprint(A)\nprint(\"\\nTransposed Matrix:\")\nprint(A_T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal Matrix:\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n\nTransposed Matrix:\n[[1 4 7]\n [2 5 8]\n [3 6 9]]\n```\n:::\n:::\n\n\n## Matrix-vector multiplication {.smaller}\n\n![](images/matrix_vec_mult_as_process.png){fig-align=\"center\"}\n\n## Matrix-vector multiplication {.smaller}\n\n**Geometrically**\n\n![](images/matrix_vec_mult_as_linear_comb_geom.png){fig-align=\"center\"}\n\n## Matrix-vector multiplication {.smaller}\n\n::: panel-tabset\n## Example\n\n-   Matrix-vector multiplication transforms the vector according to the basis vectors of the matrix.\n\n-   Formula: $\\mathbf{A} \\cdot \\mathbf{v}$\n\n$$\n\\mathbf{A} \\cdot \\mathbf{v} = \\begin{bmatrix}3 & 0 \\\\0 & 2 \\end{bmatrix} \\cdot [3, 2]\n$$\n\n## Python\n\n::: {#53ce1c9e .cell execution_count=11}\n``` {.python .cell-code}\nA = np.array([[3,0],[0,2]])\nv = np.array([3, 2])\nnew_v = A.dot(v)\nprint(new_v) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[9 4]\n```\n:::\n:::\n\n\n## Visual\n\n::: {#9531bb53 .cell execution_count=12}\n``` {.python .cell-code code-fold=\"true\"}\nA = np.array([[3, 0], [0, 2]])\nv = np.array([3, 2])\nnew_v = A.dot(v)\n\nplt.quiver(*origin, *v, color='r', scale=1, scale_units='xy', angles='xy')\nplt.quiver(*origin, *new_v, color='g', scale=1, scale_units='xy', angles='xy')\nplt.xlim(0, 10)\nplt.ylim(0, 5)\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](22-linear-algebra-I_files/figure-revealjs/cell-13-output-1.png){width=789 height=416}\n:::\n:::\n\n\n:::\n\n## Determinants {.smaller}\n\n> The [**determinant**](https://mbernste.github.io/posts/determinants/) is a function that maps square [matrices](https://mbernste.github.io/posts/matrices/) to real numbers: $\\text{Det}:ℝ^{m×m}→ℝ$\n>\n> where the absolute value of the determinant describes the volume of the parallelepided formed by the matrix’s columns.\n\n![](images/determinant_overview.png){fig-align=\"center\" width=\"732\"}\n\n## Determinants: Python {.smaller}\n\n-   Determinants measure the scale factor of a transformation.\n\n-   Determinant of 0 indicates linear dependence.\n\n::: {#b92e5f0a .cell execution_count=13}\n``` {.python .cell-code}\nfrom numpy.linalg import det\nA = np.array([[3, 0], [0, 2]])\ndeterminant = det(A)\nprint(determinant)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6.0\n```\n:::\n:::\n\n\n## `ae-15-linear-algebra`\n\nPractice matrix operations (**you will be tested on this in Exam 2**)\n\n",
    "supporting": [
      "22-linear-algebra-I_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}